### 4. 값 VS 레퍼런스

-   자바스크립트에서 레퍼런스는 (공유된) 값 자체를 가리킴.

    -   서로 다른 10개의 레퍼런스가 있다면 이 들은 저마다 항상 공유된 단일 값을 개별적으로 참조

-   값의 타입만으로 __(1)값-복사__, __(2)레퍼런스-복사__ 둘 중 결정
    -  (1) `null, undefined, string, number, boolean, symbol(ES6)` 와 같은 단순 값(스칼라 원시 값)은  
          언제나 값-복사 방식으로 할당/전달
    -  (2) 객체, 함수 등 합성 값은 레퍼런스 사본을 생성하여 할당/전달
        <br/>  

        ```
        var a = 2
        var b = a // (1)'b' 는 언제나 'a' 에서 값을 복사
        b++
        a // 2
        b // 3
    
        var c = [1,2,3]
        var d = c // (2)'d'는 공유된 '[1,2,3]' 의 레퍼런스
        d.push(4)
    
        c // [1,2,3,4]  'c' 와 'd' 는 동일한 공유 값 [1,2,3] 에 대한 개별 레퍼런스, "동등하게 참조"
        d // [1,2,3,4]
        ```

-  함수에서 인자로 변수를 전달할 때, **변수의 레퍼런스가 복사**된다. 
    -    인자 a 와 a 의 레퍼런스 사본인 x 가 있을 때 x 와 a 는 모두 동일한 값을 가리키는 별도의 레퍼런스
    -    x 에 새 값을 할당해도 a 가 가리키고 있는 값을 바꿀 수 없음. a 와 x 둘 다 가리키는 공유 값의 내용만 바꿀 수 있음.  
       <br/>

      ```
        // 레퍼런스 사본에 새 배열 할당 시
        function foo(x) {  
            x.push(4) 
            x // [1,2,3,4] 

            x = [4,5,6] // x 로 a 가 가리키는 값을 바꿀 수 없음
            x.push(7)
            x // [4,5,6,7]
        }

        var a = [1,2,3]
        foo(a) // a 의 레퍼런스 사본이 x 에 할당
        a // [1,2,3,4]
      ```
      ```
        // 레퍼런스 사본 변경 (공유 값 변경)
        function foo(x) {  
            x.push(4) 
            x // [1,2,3,4] 

            x.length = 0 // 기존 배열 비우기
            x.push(4,5,6,7) // x, a 가 공유하는 값 변경
            x // [4,5,6,7]
        }

        var a = [1,2,3]
        foo(a) 
        a // [4,5,6,7]
      ```

-  합성 값을 값-복사에 의해 전달하려면, **값의 사본**을 만든다.
      -  인자없이 slice() 호출하면 새로운 배열(얕은 복사에 의한) 사본을 만든다.  
      <br/>
      
      ```
      foo(a.slice())  
      ```

- 스칼라 원시 값을 '레퍼런스-복사처럼' 바뀐 값이 바로 반영되게 하려면, **원시 값을 합성 값으로 감싸주면** 된다.
   <br/>

   ```
   function foo(wrapper) { // obj 레퍼런스 사본 전달
        wrapper.a = 42
   }

   var obj = { a : 2 }
   foo(obj)
   obj.a // 42
   ```
