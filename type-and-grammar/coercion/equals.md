1.  느슨한/엄격한 동등 비교

    -   느슨한 동등비교 : == 연산자 사용 -> `강제변환` 허용
    -   엄격한 동등비교 : === 연산자 사용 -> `강제변환` 비허용
    -   느슨한 동등비교나 엄격한 동등비교나 타입 체크 한다! 비교과정에서 **강제변환의 개입 여부**가 다르다.

2.  추상 동등 비교

    -   NaN은 그 자신과도 결코 동등하지 않다.
    -   +0 과 -0은 동등하지 않다.
    -   느슨한 동등비교에서 피연산자의 타입이 다르면,

        -   피연산자 값이 `문자열 -> 숫자`로 ToNumber 추상연산을 통해 강제변환

            ```
            var a = 42
            var b = "42"

            a === b // false
            a == b // true ("42" -> 42 강제 변환)
            ```

        -   피연산자 값이 `불리언 -> 숫자`로 ToNumber 추상연산을 통해 강제변환

            ```
            var a = "42"
            var b = false // ToNumber(b) 는 0

            a == b // false ("42" == 0 -> 재귀적으로 42 == 0 비교)
            ```

        -   `null`과 `undefined`는 상호 간 암시적인 강제변환

            ```
            var a = null
            var b

            a == b // true
            a == null // true
            b == null // true
            ```

        -   피연산자 값이 `객체` -> `비객체` 로 ToPrimitive 추상연산을 통해 강제변환

            ```
            var a = 42
            var b = [ 42 ] -> ToPrimitive 추상연산 결과 "42", "42" -> 42

            a == b // true
            ```

            -   강제변환과 언박싱(원시 값을 감싼 객체 래퍼를 벗겨 원시 값을 반환)의 관련
